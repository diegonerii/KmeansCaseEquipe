# -*- coding: utf-8 -*-
"""CaseCPFL - Diego Stelio de Holanda Neri.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1qbnzJuEa_M2UpBnKSQCFBniRW08ghzmc
"""

import pandas as pd # trata os dados d e forma tabular
import matplotlib.pyplot as plt # plota os gráficos
from sklearn.cluster import KMeans # utiliza o algoritmo de clusterização KMeans
import numpy as np # dividir os dados em treino e teste

pontos = list(range(2, 33)); pontos

coord_x = [
          96,
          50,
          49,
          13,
          29,
          58,
          84,
          14,
          2,
          3,
          5,
          98,
          84,
          61,
          1,
          88,
          91,
          19,
          93,
          50,
          98,
          5,
          42,
          61,
          9,
          80,
          57,
          23,
          20,
          85,
          98
          ]

coord_y = [
          44,
          5,
          8,
          7,
          89,
          30,
          39,
          24,
          39,
          82,
          10,
          52,
          25,
          59,
          65,
          51,
          2,
          32,
          3,
          93,
          14,
          42,
          9,
          62,
          97,
          55,
          69,
          15,
          70,
          60,
          5
          ]

demanda = [
          19,
          21,
          6,
          19,
          7,
          12,
          16,
          6,
          16,
          8,
          14,
          21,
          16,
          3,
          22,
          18,
          19,
          1,
          24,
          8,
          12,
          4,
          8,
          24,
          24,
          2,
          20,
          15,
          2,
          14,
          9]

df = pd.DataFrame({"pontos": pontos, "coord_x": coord_x, "coord_y": coord_y, "demanda": demanda}); df

"""# Resposta Item "a"

A proposta de plotagem das informações citadas é em um Scatter Plot (gráfico de bolhas) pelos seguintes motivos:
  - Facilidade de entendimento do visual 2D
  - Ampla utilização e documentação
  
De posse do Scatter Plot, no eixo X do gráfico ficará as informações da coordenada X, no Y da coordenada Y e o tamanho das "bolhas" será referente à quantidade de demanda.

Abaixo, segue o gráfico proposto.
"""

plt.scatter(df.coord_x, df.coord_y, s=df.demanda*10)
#s = tamanho de cada ponto no gráfico. foi multiplicado por 10 para facilitar a visualização

plt.xlabel('Coordenada X')
plt.ylabel('Coordenada Y')
plt.title('Mapeamento de Serviços')



"""# Resposta Item "b "

O método descrito abaixo, e que também é minha proposta, é um resumo da clusterização que o algoritmo KMeans da biblioteca do Scikit-Learning faz. 

Ele basicamente vai levar em conta a distância entre os pontos e os centróides. Os centróides são uma espécie de ponto focal que o algoritmo identifica onde há uma grande concentração de pontos no entorno. 

A quantidade dos centróides é definida arbitrariamente pelo usuário (K). 

No caso deste case, K=5, então seriam 5 centróides e a partir de então se calcularia a distância de cada ponto para definir em qual cluster ele ficará.

# Resposta Item "c"

Como falado anteriormente, o método escolhido foi o KMeamns. As razões foram:
 - Facilidade de visualização dos resultados em um gráfico 2D; 
 - Possibilidade de customização do script;
 - Facilidade de uso a partir da linguagem Python.

Com o KMeans, o trabalho se torna mais fácil: basta definir o número de agrupamentos (5) e as variáveis preditoras (coordenadas x, y e Demanda) que o próprio algoritmo vai retornar a melhor resposta.

Observação: apesar de o total de demandas ser 410 (ficando uma média de 82 serviços por grupo), ao final do script
alguns grupos ficarão com mais, outros com menos. Isso se deve justamente ao modelo, que leva em consideração o deslocamento. No caso, as equipes que receberão menos serviços, terão um deslocamento maior.
"""

kmeans = KMeans(n_clusters = 5)
# criação do modelo

pred_y = kmeans.fit_predict(df.iloc[:, 1:], sample_weight=df.demanda)
# treinamento

sum(df.demanda)/5
# verificação da média de demanda para os 5 grupos

df['cluster'] = pred_y
# criação de nova coluna no dataframe referente ao cluster que cada ponto ficou

df

lista_clusters = list(set(df.cluster.values)); lista_clusters
# criação de uma lista para verificar os clusters criados

for i in range(0, len(lista_clusters)):
    # laço for para criar uma camada de gráfico para cada cluster
    plt.scatter(df['coord_x'][df['cluster'] == i], 
                df['coord_y'][df['cluster'] == i], 
                s=df['demanda'][df['cluster'] == i]*10,
                label = i
               )
    plt.legend()

plt.xlabel('Coordenada X')
plt.ylabel('Coordenada Y')
plt.title('Mapeamento de OS por Equipes')
plt.show()

df_novo = df.groupby(by='cluster').sum(); df_novo['demanda']
# verificação do quanto cada grupo teve de desvio da média (82)

df = df.iloc[:, 1:]

"""As etapas abaixo descrevem a solução para o caso das equipes ultrapassagem o valor de 100 demandas.

"""

#!pip install k_means_constrained

from k_means_constrained import KMeansConstrained # uso de uma alternativa do KMeans como teste (poderia ter usado o KMeans original)

clf = KMeansConstrained(n_clusters=5, size_min=6, size_max=7, random_state=0) # construção do modelo
clf.fit_predict(df) # treinamento
df['cluster'] = pred_y # nova coluna com os agrupamentos previstos
df_novo = df.groupby(by='cluster').sum() # agrupando o dataframe por cluster
df_novo['demanda'].max() # vendo a maior demanda do dataframe (verificar ultrapassou 10)

clf.fit_predict(df)

df['cluster'] = pred_y
df_novo = df.groupby(by='cluster').sum()
df_novo

lista_referencia_cluster, lista_referencia_demanda = [], []
# definindo duas listas, onde uma será os clusters que ultrapassaram e a outra as suas respectivas demandas

df_novo2 = pd.DataFrame({"Cluster": df_novo.index.values, "Demandas": df_novo['demanda'].apply(lambda x: x if x>100 else 0)})
# cria um dataframe com as duas listas

df_novo2 = df_novo2[df_novo2['Demandas']>0]; df_novo2 # filtra por maior que 0 de demanda

lista_referencia_cluster = list(df_novo2['Cluster'])
lista_referencia_demanda = list(df_novo2['Demandas'])
# caputra os valores de cada coluna do df

lista_referencia_cluster 
#mostra os valores

lista_referencia_demanda = [x for x in lista_referencia_demanda]

lista_referencia_demanda
#mostra os valores

df
# exibe o df principal

df['demanda_acumulada'] = df['demanda'][df['cluster'] == lista_referencia_cluster[0]].cumsum(); df
# cria uma coluna com a soma de demanda acumulada somente para os clusters que ultrapassaram 100

indexacao = []
# laço for para caputar as linhas para as quais as demandas terão seus clusters alterados
for i in range(0, len(df['cluster'])):
   if str(df['demanda_acumulada'][i]) != "nan":
      indexacao.append(i)
      if df['demanda_acumulada'][i] > lista_referencia_demanda[0]-100:
        break

indexacao

cluster_maximo = max(list(set(df['cluster']))); cluster_maximo
# valor de referência do cluster máximo

# LAÇO DE REDISTRIBUIÇÃO DAS DEMANDAS PELOS CLUSTERS

contador = 1
# df.iloc[indexacao[i], 3] = "valor" do cluster
# cluster_maximo = 4

for i in range(0, 3): # para cada linha que foi encontrada para valores que devem ser substituídos
  if df.iloc[indexacao[i], 3] != cluster_maximo: # se não for no cluster quatro, ele vai enviar esse valor para o cluster seguinte
    df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]+contador # envia o valor para o cluster seguinte
    
    if df.iloc[indexacao[i], 3] == cluster_maximo+1:  # retorna para o primeiro cluster, caso o último não aceite
      df.iloc[indexacao[i], 3] = 0
    
    df_novo = df.groupby(by='cluster').sum() # agrupa para ver quanto está somando cada cluster
    demanda = int(df_novo.iloc[df.iloc[indexacao[i], 3], 2]) # valor do somatório de demanda do cluster

    if demanda > 100: # caso a passagem da demanda de um cluster para outro exceda 100
      df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]-contador # retorna para o cluster original
      df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]+contador+1 # envia a demanda para o segundo cluster
      
      if df.iloc[indexacao[i], 3] == cluster_maximo+1: # retorna para o primeiro cluster, caso o último não aceite
        df.iloc[indexacao[i], 3] = 0
      
      df_novo = df.groupby(by='cluster').sum() # agrupa para ver quanto está somando cada cluster
      demanda = int(df_novo.iloc[df.iloc[indexacao[i], 3], 2]) # valor do somatório de demanda do cluster
    
    contador = contador+1
  else:
    df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]-contador # se for o cluster 4, ele vai enviar para o cluster 3
    
    if df.iloc[indexacao[i], 3] == -1: 
      df.iloc[indexacao[i], 3] = 0
    
    df_novo = df.groupby(by='cluster').sum()
    demanda = int(df_novo.iloc[df.iloc[indexacao[i], 3], 2]) # valor do somatório de demanda do cluster

    if demanda > 100: # caso a passagem da demanda de um cluster para outro exceda 100
      df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]+contador # retorna para o cluster original
      df.iloc[indexacao[i], 3] = df.iloc[indexacao[i], 3]-contador-1 # envia a demanda para o antepenúltimo cluster
      
      if df.iloc[indexacao[i], 3] == -1: # retorna para o último cluster, caso o primeiro não aceite
        df.iloc[indexacao[i], 3] = 4
      
      df_novo = df.groupby(by='cluster').sum() # agrupa para ver quanto está somando cada cluster
      demanda = int(df_novo.iloc[df.iloc[indexacao[i], 3], 2]) # valor do somatório de demanda do cluster

    contador = contador+1

# verificação se tem algumas demanda maior que 100

df_novo = df.groupby(by='cluster').sum()
df_novo

for i in range(0, len(lista_clusters)):
    plt.scatter(df['coord_x'][df['cluster'] == i], 
                df['coord_y'][df['cluster'] == i], 
                s=df['demanda'][df['cluster'] == i]*10,
                label = i
               )
    plt.legend()

plt.xlabel('Coordenada X')
plt.ylabel('Coordenada Y')
plt.title('Novo Mapeamento de OS por Equipes')
plt.show()

